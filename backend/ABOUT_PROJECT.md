Отлично, сейчас составлю подробный план реализации MVP сервиса генерации улучшенных промптов, включая backend, frontend, структуру базы данных и предложения по расширению функциональности.


# План реализации MVP

## Backend

* Реализовать регистрацию и авторизацию пользователей. Использовать OAuth2 Password (Bearer) с JWT-токенами для сессий, хранить пароли в виде хешей (например, bcrypt). После регистрации генерировать токен подтверждения по email и отправлять письмо со ссылкой (через фоновую задачу). Продумать API-эндпоинты `/register`, `/login`, `/confirm-email`, `/refresh-token` и т.д.
* Организовать проверку и учёт лимита запросов (по умолчанию 3 в сутки). Перед выполнением генерации повышенного запроса проверять, сколько запросов уже сделано за последние 24 часа; в случае превышения возвращать ошибку. Подсчёт можно делать по записям в БД о запросах пользователя или хранить в БД счётчик и дату последнего сброса.
* Реализовать интеграцию с OpenRouter. Настроить модуль, который принимает исходный промпт и выбранный стиль, формирует запрос к LLM и отправляет его на единый OpenRouter API. Пример: делать `POST` на `https://openrouter.ai/api/v1/chat/completions` с нужными заголовками и данными (см. примеры использования Python SDK и HTTP-запроса). Обрабатывать ответ и возвращать пользователю сгенерированный улучшенный промпт.
* Разработать сервисы/модули (или «routes»), отвечающие за каждый блок: модуль `auth` (регистрация, логин, генерация токенов), `user` (CRUD профиля, подтверждение email), `prompt` (логика генерации промпта через OpenRouter), `stats` (учёт запросов, лимитов).
* Создать REST-эндпоинты: `/profile` (просмотр/правка профиля), `/generate-prompt` (отправка запроса на генерацию), `/stats` (текущая статистика по лимитам), `/history` или `/prompts` (история запросов). Все защищённые запросы должны требовать JWT-токен.

## Frontend

* **Главная страница.** Статическая презентация сервиса: описание возможностей, преимуществ, принципа работы. Кнопки или ссылки для регистрации/логина.
* **Аутентификация.** Страницы регистрации и входа, формы ввода email и пароля. При успешной регистрации показывать уведомление о необходимости подтверждения email. Сохранять JWT-токен (например, в HTTP-only cookies или localStorage) для последующих запросов.
* **Личный кабинет.** После входа показывать страницу профиля: поля email, имя пользователя и т.п. Позволить редактировать данные (отдельный запрос на `/profile` или подобный). Выводить статистику: сколько запросов пользователь сделал сегодня, сколько осталось из лимита. Можно визуализировать прогресс-баром или числом (например, «1 из 3»).
* **Генерация промпта.** Отдельный интерфейс: текстовое поле для ввода исходного промпта, выпадающий список или кнопки для выбора стиля/формата (технич., креативн., формальный, и т.д.), кнопка «Сгенерировать». После отправки формы сделать запрос к бэкенду и отобразить полученный улучшенный промпт. Добавить возможность копирования результата в буфер обмена и сохранения в историю.

## Интеграция LLM (OpenRouter)

* Подключение OpenRouter: использовать их единый API, который позволяет работать со многими моделями ИИ. Можно применять OpenAI SDK (передав `base_url="https://openrouter.ai/api/v1"`) или напрямую делать HTTP-запросы. Пример кода на Python: `requests.post("https://openrouter.ai/api/v1/chat/completions", headers={"Authorization": "Bearer <ключ>"}...)`.
* В запросах передавать исходный текст и метаданные (стиль) по спецификации OpenRouter. Обработку ответа обернуть в сервис: получить сгенерированный текст и вернуть на фронтенд.

## Тестирование

* **Backend:** писать модульные тесты для сервисов FastAPI с использованием `TestClient` и `pytest`. Тестировать ключевые сценарии: успешная регистрация/авторизация, создание/сброс JWT, ограничение запросов (при достижении лимита возвращается 403 или 429), генерация промпта (можно мокать ответ OpenRouter).
* **Frontend:** проверять отображение компонентов, валидацию форм. Можно написать UI-тесты (например, Cypress) для сценария «пользователь регистрируется, логинится, отправляет запрос на генерацию».
* **Интеграция:** автоматизированные интеграционные тесты (E2E) для полного цикла регистрации и генерации промпта, включающие реальный вызов API (в тестовом режиме).

## Деплой

* **Контейнеризация:** упаковать бекенд (FastAPI) и фронтенд (Next.js) в Docker-контейнеры. БД PostgreSQL тоже можно запускать как сервис или использовать управляемый сервис (например, Yandex.Cloud, Heroku Postgres).
* **CI/CD:** настроить непрерывную интеграцию (GitHub Actions, GitLab CI) для автоматической сборки и деплоя при пуше в `main`. На продакшене развернуть приложения: фронтенд можно поднять на Vercel/Netlify или контейнер, бэкенд – на любой облачной платформе (например, Яндекс.Облако, AWS, GCP) с HTTPS.
* **Конфигурация и секреты:** обеспечить хранение секретов (ключ OpenRouter, JWT-secret) в защищённых переменных окружения. Подключить домен с SSL.
* **Мониторинг:** опционально добавить логирование (Sentry или ELK) и мониторинг (Prometheus/Grafana) для отслеживания работы сервиса и потенциальных ошибок.

## Дополнительный функционал (будущее)

* **Расширенная аналитика.** Графики использования: сколько запросов сделано в разбивке по датам, популярные стили. Уведомления о достижении лимита.
* **Платные планы.** Подключение платёжной системы (например, ЮKassa, Qiwi, YooMoney) для покупки расширенного лимита или подписки. Таблица `subscriptions` или `payments` для истории платежей. Возможность смены тарифного плана в профиле.
* **Экспорт и история.** Возможность экспортировать историю запросов в CSV/JSON. Поддержка импорта/экспорта собственных промптов или шаблонов.
* **Дополнительные роли и команды.** Поддержка разных ролей (админ, пользователь) и, возможно, групповая работа: организация команды, совместное использование сгенерированных промптов.
* **Настройки пользователя.** Расширенные пользовательские настройки (например, тема интерфейса, язык, предпочитаемые модели LLM, быстрые шаблоны промптов).

# Модели данных (PostgreSQL)

* **`users`**:

  * `id`: `SERIAL PRIMARY KEY` – уникальный идентификатор пользователя.
  * `email`: `VARCHAR(255) UNIQUE NOT NULL` – почта (логин), используется при входе и для подтверждения.
  * `password_hash`: `VARCHAR(255) NOT NULL` – хеш пароля (например, bcrypt).
  * `name`: `VARCHAR(100)` – имя пользователя (опционально).
  * `is_email_confirmed`: `BOOLEAN DEFAULT FALSE` – флаг подтверждения email.
  * `daily_limit`: `INT DEFAULT 3` – лимит запросов в сутки (можно увеличивать для подписчиков).
  * `requests_today`: `INT DEFAULT 0` – сколько запросов сделано сегодня (сбрасывать при переходе на новую дату).
  * `last_request_date`: `DATE` – дата последнего запроса (для сброса счётчика).
  * `created_at`, `updated_at`: `TIMESTAMP` – метки создания/обновления записи.

* **`prompt_requests`** (история запросов генерации):

  * `id`: `SERIAL PRIMARY KEY`.
  * `user_id`: `INT NOT NULL` – внешний ключ на `users(id)`, указывает автора запроса.
  * `original_prompt`: `TEXT NOT NULL` – исходный текст промпта, введённый пользователем.
  * `style`: `VARCHAR(50)` – выбранный стиль/формат (например, «technical», «creative»). Можно сделать внешним ключом на справочник стилей.
  * `generated_prompt`: `TEXT` – полученный от LLM сгенерированный промпт.
  * `created_at`: `TIMESTAMP NOT NULL DEFAULT NOW()` – время создания запроса.

* **`prompt_styles`** (справочник стилей, опционально):

  * `id`: `SERIAL PRIMARY KEY`.
  * `name`: `VARCHAR(50) UNIQUE NOT NULL` – код или название стиля.
  * `description`: `TEXT` – описание стиля (для подсказки пользователю).

* **`user_daily_usage`** или **`user_stats`** (если не храним счётчик в `users`):

  * `id`: `SERIAL PRIMARY KEY`.
  * `user_id`: `INT NOT NULL` – FK к `users`.
  * `date`: `DATE NOT NULL` – день статистики.
  * `requests_count`: `INT DEFAULT 0` – число запросов, сделанных в этот день.

* **`user_settings`** (настройки пользователя, опционально):

  * `id`: `SERIAL PRIMARY KEY`.
  * `user_id`: `INT UNIQUE NOT NULL` – FK к `users`.
  * `default_style_id`: `INT` – ссылка на `prompt_styles`, предпочитаемый стиль.
  * `other_prefs`: `JSONB` – дополнительные настройки (например, тема интерфейса).

Каждая из таблиц должна быть связана внешними ключами: `prompt_requests.user_id` → `users.id`, `user_daily_usage.user_id` → `users.id`, `user_settings.user_id` → `users.id`. Поле `users.password_hash` хранит хеш пароля, а не сам пароль, что соответствует рекомендациям по безопасности. Эти модели покрывают базовый функционал – хранение пользователей, истории запросов и статистики, необходимых для работы MVP.

**Источники:** официальная документация FastAPI по безопасности (рекомендации по JWT и хешированию паролей), пример отправки email-подтверждения, руководство по OpenRouter API, а также общие принципы SQL-дизайна (например, хранение хеша пароля в VARCHAR(255) и установка внешнего ключа на `users.id`).
